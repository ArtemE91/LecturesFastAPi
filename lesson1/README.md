# Начало работы с FastAPI

### План занятия

1) Создание изолированных систем разработки virtualenv
2) Управление пакетами с помощью pip
3) Создание простого приложения FastAPI
4) Основы Git
5) Настройка Docker


### <font color="#46aa63">Создание изолированных систем разработки virtualenv</font>

Традиционный подход к разработке приложений на Python заключается в изоляции этих приложений в виртуальной среде. Это сделано для того, чтобы избежать глобальной установки пакетов и уменьшить количество конфликтов во время разработки приложений.

Виртуальная среда — это изолированная среда, в которой установленные зависимости приложений доступны только внутри нее. В результате приложение может получать доступ только к пакетам и взаимодействовать только внутри этой среды.

##### <font color="#46aa63">Установка venv и python на Ubuntu</font>

```shell  
sudo apt install
sudo apt upgrade
sudo add-apt-repository ppa:deadsnakes/ppa
sudo apt update
sudo apt install python3.11
sudo apt-get install python3.11-venv
```

Создадим директорию `lesson1` перейдем в нее и создадим виртуальную среду:

```shell
mkdir lesson1 %% cd lesson1
python3.11 --version
python3 -m venv venv
ls
```  

Активируем виртуальную среду для работы:
```shell
source venv/bin/activate
```

Для деактивации виртуальной среды необходимо выполнить команду **deactivate**
```shell
deactivate
```

### <font color="#46aa63">Управление пакетами с помощью pip</font>

Приложение `FastAPI` представляет собой пакеты, поэтому вы познакомитесь с методами управления пакетами, такими как установка пакетов, удаление пакетов и обновление пакетов для вашего приложения.

**Pip** — это менеджер пакетов Python, подобный JavaScript’s yarn; он позволяет автоматизировать процесс установки пакетов Python как глобально, так и локально.

Pip автоматически устанавливается во время установки Python. Вы можете проверить, установлен ли pip, выполнив следующую команду в своем терминале:

```shell
python3 -m pip list
Package    Version
---------- -------
pip        22.3.1
setuptools 65.5.1
wheel      0.38.4

```

##### <font color="#46aa63">Основные команды</font>

Чтобы установить пакет FastAPI с помощью pip, мы запускаем следующую команду:
```shell
pip install fastapi
```

Для удаления пакета используется следующая команда:

```shell
pip uninstall fastapi
```

Для запуска сервера будем использовать ASGI веб-сервер для Python **uvicorn**. Для установки его пакета запускаем следующую команду:

```shell
pip install uvicorn
```

Чтобы собрать текущие пакеты, установленные в проекте, в файл, мы используем следующую команду:

```shell
pip freeze > requirements.txt
```

После записи зависимостей в файл `requirements.txt` он будет выглядеть следующим образом:

```txt
annotated-types==0.7.0  
anyio==4.4.0  
click==8.1.7  
fastapi==0.114.0  
h11==0.14.0  
idna==3.8  
pydantic==2.9.0  
pydantic_core==2.23.2  
sniffio==1.3.1  
starlette==0.38.5  
typing_extensions==4.12.2  
tzdata==2024.1  
uvicorn==0.30.6
```

Чтобы установить пакеты из файла, такого как файл `requirements.txt`, используется следующая команда:

```shell
pip install -r requirements.txt
```

Предыдущая команда в основном используется при развертывании.

### <font color="#46aa63">Создание простого приложения FastAPI</font>

Выше мы установили зависимости, необходимые для нашего приложения, в папку `lesson1`. Зависимости следующие:

- **fastapi**  - фреймворк, на котором мы будем строить наше приложение
- **uvicorn** - модуль Asynchronous Server Gateway Interface для запуска приложения.

Cоздадим новый файл `api.py` и создадим новый экземпляр FastAPI следующим образом:

```python
from fastapi import FastAPI 

app = FastAPI()
```

Создав экземпляр FastAPI в переменной приложения, мы можем приступить к созданию маршрутов. Создадим приветственный маршрут.

Маршрут создается, сначала определяя декоратор для указания типа операции, а затем функцию, содержащую операцию, которая будет выполняться при вызове этого маршрута. В следующем примере мы создадим маршрут "/", который принимает только запросы GET requests и возвращает приветственное сообщение при посещении:

```python
@app.get("/")  
async def welcome() -> dict:

return { "message": "Hello World"}
```

Следующим шагом будет запуск нашего приложения с помощью `uvicorn`. В терминале выполните следующую команду:

```shell
uvicorn api:app --host 127.0.0.1 --port 8000 --reload
```

Команда возвращает следующий вывод:

```shell
(venv) arteme@MacBook-Air-3 lesson1 % uvicorn api:app --host 127.0.0.1 --port 8000 --reload
INFO:     Will watch for changes in these directories: ['/Users/arteme/PycharmProjects/MISISFastAPi/lesson1']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [25667] using StatReload
INFO:     Started server process [25671]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
```

В предыдущей команде, `uvicorn` принимает следующие аргументы:

- **filename:instance** - файл, содержащий экземпляр FastAPI и переменную имени, содержащую экземпляр FastAPI.
- **--host** - хост на котором будет обслуживаться приложение
- **--port** - порт на котором будет обслуживаться приложение
- **--reload** - Необязательный аргумент, включенный для перезапуска приложения при каждом изменении файла

Так же проект можно запустить через python файл запустив uvicorn в нем. Для этого необходимо добавить в файл `api.py` следующие строки:

```python
import uvicorn

if __name__ == "__main__":
	uvicorn.run("api:app", host="127.0.0.1", port=8000, log_level="info", reload=True)
```

Запуск приложения:

```shell
python api.py
```

## <font color="#46aa63">Основы Git</font>

**Git** - это технология, предназначенная для отслеживания изменений в проекте и для помощи в организации совместной работы над проектом. На базовом уровне проект, контролируемый Git, состоит из каталога (папки) с файлами внутри, и Git отслеживает изменения, вносимые в файлы проекта. Это позволяет вам сохранять разные версии выполняемой вами работы, поэтому Git называют системой контроля версий.

Git был создан Линусом Торвальдсом для контроля версий при работе над большим проектом - разработкой ядра Linux. Однако, поскольку Git может отслеживать изменения во всех типах файлов, он подходит для самых разных проектов.

Скачать и установить git можно на странице загрузок [https://git-scm.com/downloads](https://git-scm.com/downloads)

##### <font color="#46aa63">Локальные репозитории</font>

 **Репозиторий** это, по сути, способ указать на место хранения проекта, версию которого контролирует `Git`. На самом деле существуют два типа репозиториев:
- `локальный репозиторий` - это репозиторий, размещенный на вашем компьютере
- `удаленный репозиторий` - это репозиторий, размещенный на сервере хостинговой службы

**Хостинговая служба** - это компания, предоставляющая хостинг (размещение файлов на удаленном сервере) проектам, использующим `Git`. Например GitHub (https://github.com) или GitLab (https://about.gitlab.com).

##### <font color="#46aa63">Инициализация локального репозитория</font>

Локальный репозиторий представлен скрытым каталогом с именем `.git`, который расположен в каталоге проекта. Он содержит все данные об изменениях, внесенных в файлы проекта.

Для того чтобы превратить каталог проекта в локальный репозиторий, вам необхо­димо инициализировать репозиторий по месту расположения проекта. Когда вы инициализируете репозиторий, внутри каталога проекта автоматически создается каталог `.git`. Поскольку это скрытый каталог, вы не сможете его увидеть, если явно не сделаете видимыми скрытые файлы и каталоги в настройках файловой системы.

Для инициализации репозитория `Git` применяется команда **git init**. При выполне­нии этой команды вашим текущим каталогом должен быть каталог проекта, кото­рый вы хотите превратить в репозиторий.

Обычно пользователи Git инициализируют репозиторий, выполняя только команду **git init**  без дополнительных параметров; на занятии мы инициализируем репозиторий с помощью команды **git init** с опцией **-b** (сокращение от --initial-branch) и передадим имя ветки `main`.  По умолча­нию `Git` создает ветку с именем `master`, когда вы инициализируете новый локаль­ный репозиторий. Начиная с версии `Git 2.28`, имя начальной ветки можно настраивать. Мы будем использовать имя `main` вместо `master`, поскольку слово "master" считается недостаточно политкорректным. 

После инициализации репозитория создаться каталог `.git`. Внутри этого каталога находятся различные файлы и каталоги. Некоторые из них представляют области Git, о которых мы узнаем позже. 

![Снимок экрана 2024-09-27 в 11.23.11.png](images%2F%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-09-27%20%D0%B2%2011.23.11.png)

##### <font color="#46aa63">Области Git</font>

При работе с `Git`  следует обращать внимание на четыре важные области:
- рабочий каталог
- промежуточная область
- история коммитов
- локальный репозиторий

![Снимок экрана 2024-09-26 в 15.35.23.png](images%2F%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-09-26%20%D0%B2%2015.35.23.png)

О **локальном репозитории** мы узнали выше. В этом разделе мы рассмотрим остальные области и то, как они связаны друг с другом. Начнем с рабочего каталога.

**Рабочий каталог** содержит файлы и каталоги, которые представляют одну версию проекта. Это что-то вроде рабочего верстака. Здесь вы можете добавлять, редакти­ровать и удалять файлы и каталоги.

**Промежуточная область** (staging area), которую часто также называют индексом (index), похожа на черновик. Здесь вы можете добавлять и удалять файлы, когда готовите содержимое для включения в следующую сохраненную версию вашего проекта (сле­дующий коммит). Промежуточная область представлена файлом `index` в каталоге `.git`.

**Коммит** (commit) в Git - это, по сути, одна версия проекта. Вы можете рассматривать его снимок проекта или как отдельную версию проекта, содержащую ссылки на все файлы, являющиеся частью этого коммита.

У каждого коммита есть хеш коммита (иногда называемый идентификатором коммита). Это уникальный 40-символьный хеш, состоящий из букв и цифр, который действует как имя коммита и позволяет ссылаться на него.

Пример хеша коммита: `51dcбecb327578cca503abba4a56e8c18f3835el`.

**История коммитов** (commit history)- это место, где хранится информация о существующих коммитах. Она представлена каталогом `objects` внутри каталога `.git`. Для того чтобы глубже понять историю коммитов, нам придется углубиться во внутреннее устройство Git, но это сложная тема, знание которой нам не понадобит­ся при изучении основ использования `Git`. Для наших целей все, что нам нужно знать: каждый раз, когда вы делаете коммит, он сохраняется в истории коммитов.


##### <font color="#46aa63">Настройка конфигурации Git</font>

**Конфигурации Git** - это настройки, которые позволяют вам управлять работой Git. Они состоят из переменных и их значений и хранятся в нескольких разных файлах. Для работы с Git необходимо настроить значения нескольких переменных конфи­гурации, связанных с настройками пользователя.

Прежде чем настраивать какие-либо переменные, необходимо проверить, сущест­вует ли глобальный файл конфигурации Git в вашей файловой системе, и если да, то какие значения переменных были установлены. Для этого воспользуйтесь ко­мандой `git config`, передав ей параметры `--global` и `—list`.

```shell
git config --global --list
fatal: unable to read config file '/home/etemik/.gitconfig': No such file or directory
git config --global user.name "<имя>"
git config --global user.email "<адрес email>"
```

##### <font color="#46aa63">Основные команды Git</font>

- **init** - инициализация репозитория
- **add** - начать отслеживать (добавить под версионный контроль) новый файл
- **commit** - снимок состояния проекта на текущий момент времени
- **status** - отображает состояние рабочего каталога и промежуточной области
- **diff** - инициирует функцию сравнения источников данных Git
- **checkout** - позволяет перемещаться между ветками
- **branch** - создание, просмотр, переименование и удаление ветки
- **merge** - слияние отдельных направлений разработки, созданных с помощью команды
- **push** - передать изменения из локального репозитория в удаленный
- **pull** - загружает ветку из удаленного репозитория и объединяет с текущей


##### <font color="#46aa63">Инициализация локального репозитория и первый коммит</font>

```shell
mkdir lesson1 && cd lesson1
git init -b main
Initialized empty Git repository in /home/etemik/projects/lesson1/.git/

git status
On branch main
No commits yet
nothing to commit (create/copy files and use "git add" to track)
```

Создадим файл `.gitignore` чтобы игнорировать файлы виртуальной среды, кеша и IDE:

```shell
echo ".idea \nvenv\n__pycache__" >> .gitignore
```

Добавим на отслеживание в git нашу директорию выполнив команду:

```shell
git add .
git status
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   .gitignore
        new file:   api.py
        new file:   requirements.txt
```

Выполним коммит:

```shell
git commit -m "Initial commit"
[main (root-commit) cfc39bf] Initial commit
 3 files changed, 29 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 api.py
 create mode 100644 requirements.txt```

##### <font color="#46aa63">Создание ветки и ускоренное слияние</font>

Существует два типа слияний:
• ускоренные слияния  
• трехсторонние слияния

Фактором, от которого зависит, по какому типу произойдет слияние исходной вет­ки с целевой, является наличие или отсутствие факта, разошлись ли истории разви­тия двух веток. Историю развития ветки можно проследить, пройдя по родитель­ским ссылкам коммитов.

Создадим новую ветку и перейдем на нее.

```shell
git branch feature
git checkout feature
Switched to branch 'feature'

git branch
* feature
  main
```

Внесем изменения в файл `api.py`:

```python
@app.get("/")  
async def welcome() -> dict:  
    return {"message": "Hello World!!!"}
```

Закомитим изменения:

```shell
git status
On branch feature
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   api.py

git add api.py
git status
On branch feature
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   api.py

git commit -m "first commit in the branch feature"
[feature 49e9a1a] first commit in the branch feature
 1 file changed, 1 insertion(+), 1 deletion(-)

```

Так как мы можем добраться до одной ветки через историю коммитов другой ветки, мы говорим, что истории развития ветвей не разошлись. Если я пройду по роди­тельской ссылки из ветки feature, которая указывает на коммит 49e9a1, назад, я доберусь до ветки main, которая указывает на коммит cfc39bf. Следовательно, ветки main и feature не разошлись.

Если мы объединим ветку feature с веткой main, произойдет уско­ренное слияние. Во время ускоренного слияния указатель ветки main переместится вперед и будет указывать на коммит, на который указывает ветка feature , т. е. коммит 49e9a1.

Объединим ветки:

```shell
git checkout main
git merge feature
git log

commit 49e9a1a54cbb1e0d3da86b9e8e3936aaaef4f39a (HEAD -> main, feature)
Author: arteme <temik91Efremov@gmail.com>
Date:   Mon Sep 9 14:57:19 2024 +0300

    first commit in the branch feature

commit cfc39bf9c8f346fe38098cb728edbcecfedd79f3
Author: arteme <temik91Efremov@gmail.com>
Date:   Mon Sep 9 12:22:08 2024 +0300

    Initial commit
```

Как видим из вывода выше, обе ветки указывают на один и тот же коммит.

##### <font color="#46aa63">Трехсторонние слияние</font>

Перейдем в ветку feature, создадим файл `settings.py` и выполним коммит. После этого перейдем в ветку main, создадим файл `schema.py` и выполним коммит.

```shell
git checkout feature
git add .
git commit -m "add settings.py"

git checkout main
git add .
git commit -m "add schema.py"

git log --all --graph --oneline
* 3a180f4 (HEAD -> main) add schema.py
| * 59b7530 (feature) add settings.py
|/  
* 49e9a1a first commit in the branch feature
* cfc39bf Initial commit
```

Как видим выше невозможно пройти по родительским ссылкам ветки **feature** назад, чтобы достичь коммита 3a180f4 , на который указывает ветка **main**. В  
этой ситуации мы говорим, что истории развития веток разошлись.

Если я захочу объединить ветку **feature** с веткой **main**, это не может быть быстрым слиянием, потому что невозможно просто переместить указатель ветки вперед, чтобы объединить эти две истории разработки. Вместо этого будет создан коммит слияния, чтобы связать две истории разработки вместе. Коммит слияния - это коммит, имеющий более одного родителя. Он служит примером трехстороннего слияния (three-way merge).

Выполним **merge** в ветку main. У нас откроется в терминале Vim. Для написания сообщений о коммите Git по умолчанию использует текстовый редактор в окне командной строки под названием Vim. Если выполняется коммит (как обычный, так коммит слияния) и сообщение коммита не указано, Git запустит Vim в окне командной строки. 

```shell
git merge feature
git log --all --graph --oneline
*   98aa22a (HEAD -> main) Merge branch 'feature'
|\  
| * 59b7530 (feature) add settings.py
* | 3a180f4 add schema.py
|/  
* 49e9a1a first commit in the branch feature
* cfc39bf Initial commit

git checkout feature
git merge main
git log --all --graph --oneline
*   98aa22a (HEAD -> feature, main) Merge branch 'feature'
|\  
| * 59b7530 add settings.py
* | 3a180f4 add schema.py
|/  
* 49e9a1a first commit in the branch feature
* cfc39bf Initial commit
```

## <font color="#46aa63">Настройка Docker</font>

По мере того, как наше приложение становится многоуровневым, например, база данных, объединение приложения в единый элемент позволяет нам развертывать наше приложение. Мы будем использовать Docker для контейнеризации уровней наших приложений в единый образ, который затем можно будет легко развернуть локально или в облаке.

Кроме того, использование Dockerfile и файла docker-compose избавляет от необходимости загружать образы наших приложений и делиться ими. Новые версии наших приложений можно создавать из файла Dockerfile и развертывать с помощью файла docker-compose. Образы приложений также можно хранить и извлекать из Docker Hub. Это известно, как операция толкания и вытягивания.

Чтобы начать настройку, загрузите и установите Docker с https://docs.docker.com/install.

##### <font color="#46aa63">Dockerfile</font>

Dockerfile содержит инструкции о том, как должен быть создан образ нашего приложения. Ниже приведен пример Dockerfile:

```txt
#  
FROM python:3.11  
#  
WORKDIR /code  
#  
COPY ./requirements.txt /code/requirements.txt  
#  
RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt  
#  
COPY . /code/lesson1  
#  
CMD ["uvicorn", "lesson1.api:app", "--host", "0.0.0.0", "--port", "80"]
```

На данном этапе структура проекта должны выглядеть так:

```txt
├── lesson1 │ 
	├── .gitignore       │
	├── api.py           │
	├── Dockerfile       │
	└── requirements.txt │

```

Далее мы создадим образ контейнера приложения и назовем **myimage** следующим образом:

```shell
docker build -t myimage .
docker images | grep myimage
myimage                                              latest          54d195945e6d   35 seconds ago   1.07GB
```

Запустим контейнер, основанный на нашем образе:

```shell
docker run -d --name mycontainer -p 80:80 myimage
docker ps -a | grep myimage
c8377e112d41   myimage                    "uvicorn lesson1.api…"   22 seconds ago   Up 20 seconds                0.0.0.0:80->80/tcp           mycontainer
```

Остановим контейнер:
```shell
docker stop c8377e112d41
c8377e112d41
```


## <font color="#46aa63">Заключение</font>

На этом занятии мы узнали, как установить инструменты, необходимые для настройки нашей среды разработки. Мы также создали простой API в качестве введения в FastAPI и научились создавать маршрут в процессе.

## <font color="#46aa63">Домашнее задание</font>

